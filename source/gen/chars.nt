import {
  core.char {Char1, Char2, Char3, Char4},
  core.char.entity {as-entity},
  core.char.loset {as-loset},
  core.char.show,
  core.entity {Entity, entity},
  core.entity.list {from-entity, trope},
  core.list {filter},
  core.order {GT},
  core.random {random, random-in-range},
  this.gen {Gen, gen},
}

// [U+0000, U+007F]
define _random-1-byte-char(): char {
  let char = trunc-int-int8(random(0x80)) in
  Char1(char)
}

// [U+0080, U+07FF]
define _random-2-byte-char(): char {
  let mask-X = 0b_1100_0000_1000_0000 in
  let mask-0 = 0b_0000_0111_1100_0000 in
  let mask-1 = 0b_0000_0000_0011_1111 in
  let value = trunc-int-int16(random-in-range(0x0080, 0x07ff)) in
  // let value = 0x00AB in
  let value-0 = and-int16(mask-0, value) in
  let value-1 = and-int16(mask-1, value) in
  let value-0' = shl-int16(value-0, 2) in
  let char = or-int16(or-int16(mask-X, value-0'), value-1) in
  let piece-0 = trunc-int16-int8(lshr-int16(and-int16(0b_1111_1111_0000_0000, char), 8)) in
  let piece-1 = trunc-int16-int8(and-int16(0b_0000_0000_1111_1111, char)) in
  Char2(piece-0, piece-1)
}

// [U+0800, U+FFFF]
define _random-3-byte-char(): char {
  let mask-X = 0b_1110_0000_1000_0000_1000_0000 in
  let mask-0 = 0b_0000_0000_1111_0000_0000_0000 in
  let mask-1 = 0b_0000_0000_0000_1111_1100_0000 in
  let mask-2 = 0b_0000_0000_0000_0000_0011_1111 in
  let value = trunc-int-int24(random-in-range(0x0800, 0xffff)) in
  let value-0 = and-int24(mask-0, value) in
  let value-1 = and-int24(mask-1, value) in
  let value-2 = and-int24(mask-2, value) in
  let value-0' = shl-int24(value-0, 4) in
  let value-1' = shl-int24(value-1, 2) in
  let char = or-int24(or-int24(or-int24(mask-X, value-0'), value-1'), value-2) in
  let piece-0 = trunc-int24-int8(lshr-int24(and-int24(0b_1111_1111_0000_0000_0000_0000, char), 16)) in
  let piece-1 = trunc-int24-int8(lshr-int24(and-int24(0b_0000_0000_1111_1111_0000_0000, char), 8)) in
  let piece-2 = trunc-int24-int8(and-int24(0b_0000_0000_0000_0000_1111_1111, char)) in
  Char3(piece-0, piece-1, piece-2)
}

// [U+10000, U+10FFFF]
define _random-4-byte-char(): char {
  let mask-X: int32 = 0b_1111_0000_1000_0000_1000_0000_1000_0000 in
  let mask-0: int32 = 0b_0000_0000_0001_1100_0000_0000_0000_0000 in
  let mask-1: int32 = 0b_0000_0000_0000_0011_1111_0000_0000_0000 in
  let mask-2: int32 = 0b_0000_0000_0000_0000_0000_1111_1100_0000 in
  let mask-3: int32 = 0b_0000_0000_0000_0000_0000_0000_0011_1111 in
  let value = trunc-int-int32(random-in-range(0x10000, 0x10FFFF)) in
  let value-0 = and-int32(mask-0, value) in
  let value-1 = and-int32(mask-1, value) in
  let value-2 = and-int32(mask-2, value) in
  let value-3 = and-int32(mask-3, value) in
  let value-0' = shl-int32(value-0, 6) in
  let value-1' = shl-int32(value-1, 4) in
  let value-2' = shl-int32(value-2, 2) in
  let char = or-int32(or-int32(or-int32(or-int32(mask-X, value-0'), value-1'), value-2'), value-3) in
  let piece-0 = trunc-int32-int8(lshr-int32(and-int32(0b_1111_1111_0000_0000_0000_0000_0000_0000, char), 24)) in
  let piece-1 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_1111_1111_0000_0000_0000_0000, char), 16)) in
  let piece-2 = trunc-int32-int8(lshr-int32(and-int32(0b_0000_0000_0000_0000_1111_1111_0000_0000, char), 8)) in
  let piece-3 = trunc-int32-int8(and-int32(0b_0000_0000_0000_0000_0000_0000_1111_1111, char)) in
  Char4(piece-0, piece-1, piece-2, piece-3)
}

define _gen-char(_: int): char {
  let char-kind = random(4) in
  if eq-int(char-kind, 0) {
    _random-1-byte-char()
  } else-if eq-int(char-kind, 1) {
    _random-2-byte-char()
  } else-if eq-int(char-kind, 2) {
    _random-3-byte-char()
  } else {
    _random-4-byte-char()
  }
}

constant _char-entity-N: entity(&char) {
  Entity of {
    identity = {
      function (x, y) {
        as-entity::identity(*x, *y)
      }
    },
  }
}

constant _list-char-ops: trope(char) {
  from-entity(_char-entity-N)
}

constant _simple-chars: list(char) {
  [
    // "b"
    Char1(0x62),
    // "a"
    Char1(0x61),
    // "B",
    Char1(0x42),
    // "A",
    Char1(0x41),
  ]
}

define _extract-candidates(c: char): list(char) {
  let cs = _simple-chars in
  let is-elem on c, cs = _list-char-ops::elem(c, cs) in
  let _ = cs in
  if is-elem {
    let pred =
      function (c') {
        match as-loset::cmp(c, c') {
        | GT =>
          True
        | _ =>
          False
        }
      }
    in
    filter(pred, _simple-chars)
  } else {
    [Char1(0x41)]
  }
}

constant chars: gen(char) {
  Gen of {
    generate = _gen-char,
    shrink = {
      function (c) {
        _extract-candidates(*c)
      }
    },
    viewer = core.char.show.as-show,
  }
}
